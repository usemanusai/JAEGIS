# {{Project Name}} - Deployment Script Template
*Generated with JAEGIS Enhanced Validation & Research*

[[LLM: VALIDATION CHECKPOINT - Review shared context from infrastructure architecture and validate all deployment requirements. Integrate web research findings for current deployment automation patterns and security best practices.]]

## Executive Summary

[[LLM: RESEARCH INTEGRATION - Include current deployment automation best practices and validated script configurations. All deployment scripts must be researched for security, reliability, and current standards.]]

## Script Configuration

[[LLM: VALIDATION CHECKPOINT - All deployment scripts must be validated for security, error handling, and current best practices. Include research-backed deployment automation techniques.]]
**Target Platforms**: Windows, macOS, Linux, Docker, Cloud  
**Script Types**: PowerShell (.ps1), Bash (.sh), Python (.py)  

## PowerShell Deployment Script Template

### 🪟 **Windows PowerShell Script (.ps1)**
```powershell
#Requires -Version 5.1
#Requires -RunAsAdministrator

<#
.SYNOPSIS
    {application_name} Deployment Script
    Generated by Phoenix Agent on {current_date}

.DESCRIPTION
    Cross-platform deployment automation for {application_name}
    Supports Windows 10/11 and Windows Server 2019/2022

.PARAMETER Environment
    Target deployment environment (development, staging, production)

.PARAMETER ConfigPath
    Path to configuration files directory

.PARAMETER SkipDependencies
    Skip dependency installation and validation

.PARAMETER Rollback
    Perform rollback to previous version

.EXAMPLE
    .\deploy.ps1 -Environment production -ConfigPath ".\config"
    .\deploy.ps1 -Environment staging -SkipDependencies
    .\deploy.ps1 -Rollback
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [ValidateSet("development", "staging", "production")]
    [string]$Environment = "production",
    
    [Parameter(Mandatory=$false)]
    [string]$ConfigPath = ".\config",
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipDependencies,
    
    [Parameter(Mandatory=$false)]
    [switch]$Rollback,
    
    [Parameter(Mandatory=$false)]
    [switch]$DryRun
)

# Script metadata
$Script:Metadata = @{
    Name = "{application_name}"
    Version = "{application_version}"
    GeneratedDate = "{current_date}"
    Agent = "Phoenix"
    Platform = "Windows"
    PowerShellVersion = $PSVersionTable.PSVersion.ToString()
}

# Configuration
$Script:Config = @{
    ApplicationName = "{application_name}"
    ApplicationVersion = "{application_version}"
    DeploymentDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    Environment = $Environment
    ConfigPath = $ConfigPath
    LogPath = ".\logs\deployment-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
    BackupPath = ".\backups\backup-$(Get-Date -Format 'yyyyMMdd-HHmmss')"
}

# Logging functions
function Write-Log {
    param(
        [string]$Message,
        [ValidateSet("INFO", "WARN", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # Console output with colors
    switch ($Level) {
        "INFO"    { Write-Host $logEntry -ForegroundColor Cyan }
        "WARN"    { Write-Host $logEntry -ForegroundColor Yellow }
        "ERROR"   { Write-Host $logEntry -ForegroundColor Red }
        "SUCCESS" { Write-Host $logEntry -ForegroundColor Green }
    }
    
    # File logging
    if (-not (Test-Path (Split-Path $Script:Config.LogPath))) {
        New-Item -ItemType Directory -Path (Split-Path $Script:Config.LogPath) -Force | Out-Null
    }
    Add-Content -Path $Script:Config.LogPath -Value $logEntry
}

# Platform validation
function Test-PlatformCompatibility {
    Write-Log "Validating platform compatibility..." "INFO"
    
    # Windows version check
    $osVersion = [System.Environment]::OSVersion.Version
    if ($osVersion.Major -lt 10) {
        throw "Windows 10 or later required. Current version: $($osVersion.ToString())"
    }
    
    # PowerShell version check
    if ($PSVersionTable.PSVersion.Major -lt 5) {
        throw "PowerShell 5.1 or later required. Current version: $($PSVersionTable.PSVersion.ToString())"
    }
    
    # Architecture check
    $architecture = [System.Environment]::GetEnvironmentVariable("PROCESSOR_ARCHITECTURE")
    Write-Log "Platform: Windows $($osVersion.ToString()) ($architecture)" "INFO"
    Write-Log "PowerShell: $($PSVersionTable.PSVersion.ToString())" "INFO"
    
    Write-Log "Platform compatibility validated" "SUCCESS"
}

# Dependency management
function Install-Dependencies {
    if ($SkipDependencies) {
        Write-Log "Skipping dependency installation" "INFO"
        return
    }
    
    Write-Log "Installing dependencies..." "INFO"
    
    # Check for package managers
    $packageManagers = @()
    
    if (Get-Command winget -ErrorAction SilentlyContinue) {
        $packageManagers += "winget"
    }
    
    if (Get-Command choco -ErrorAction SilentlyContinue) {
        $packageManagers += "chocolatey"
    }
    
    if ($packageManagers.Count -eq 0) {
        Write-Log "No package manager found. Installing Chocolatey..." "WARN"
        Set-ExecutionPolicy Bypass -Scope Process -Force
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
        iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
        $packageManagers += "chocolatey"
    }
    
    # Install required dependencies
    $dependencies = @{
        {dependency_list}
    }
    
    foreach ($dep in $dependencies.GetEnumerator()) {
        try {
            Write-Log "Installing $($dep.Key)..." "INFO"
            
            if ("winget" -in $packageManagers) {
                winget install --id $dep.Value --silent --accept-package-agreements --accept-source-agreements
            } elseif ("chocolatey" -in $packageManagers) {
                choco install $dep.Value -y
            }
            
            Write-Log "$($dep.Key) installed successfully" "SUCCESS"
        } catch {
            Write-Log "Failed to install $($dep.Key): $($_.Exception.Message)" "ERROR"
            throw
        }
    }
}

# Configuration management
function Set-Configuration {
    Write-Log "Loading configuration for environment: $Environment" "INFO"
    
    $configFile = Join-Path $ConfigPath "$Environment.json"
    
    if (-not (Test-Path $configFile)) {
        Write-Log "Configuration file not found: $configFile" "ERROR"
        throw "Configuration file not found: $configFile"
    }
    
    try {
        $config = Get-Content $configFile | ConvertFrom-Json
        
        # Set environment variables
        foreach ($property in $config.PSObject.Properties) {
            [Environment]::SetEnvironmentVariable($property.Name, $property.Value, "Process")
            Write-Log "Set $($property.Name) = $($property.Value)" "INFO"
        }
        
        Write-Log "Configuration loaded successfully" "SUCCESS"
        return $config
    } catch {
        Write-Log "Failed to load configuration: $($_.Exception.Message)" "ERROR"
        throw
    }
}

# Backup current deployment
function Backup-CurrentDeployment {
    Write-Log "Creating backup of current deployment..." "INFO"
    
    if (-not (Test-Path $Script:Config.BackupPath)) {
        New-Item -ItemType Directory -Path $Script:Config.BackupPath -Force | Out-Null
    }
    
    # Backup application files
    $applicationPath = "{application_path}"
    if (Test-Path $applicationPath) {
        Copy-Item -Path $applicationPath -Destination $Script:Config.BackupPath -Recurse -Force
        Write-Log "Application files backed up to $($Script:Config.BackupPath)" "SUCCESS"
    }
    
    # Backup configuration
    if (Test-Path $ConfigPath) {
        Copy-Item -Path $ConfigPath -Destination (Join-Path $Script:Config.BackupPath "config") -Recurse -Force
        Write-Log "Configuration backed up" "SUCCESS"
    }
}

# Health checks
function Test-DeploymentHealth {
    Write-Log "Running deployment health checks..." "INFO"
    
    $healthChecks = @(
        @{ Name = "Application Service"; Test = { Test-NetConnection localhost -Port {application_port} -WarningAction SilentlyContinue } },
        @{ Name = "Database Connection"; Test = { {database_health_check} } },
        @{ Name = "External APIs"; Test = { {api_health_check} } },
        @{ Name = "File System Access"; Test = { Test-Path "{application_path}" } }
    )
    
    $failedChecks = @()
    
    foreach ($check in $healthChecks) {
        try {
            $result = & $check.Test
            if ($result) {
                Write-Log "$($check.Name) check passed" "SUCCESS"
            } else {
                Write-Log "$($check.Name) check failed" "ERROR"
                $failedChecks += $check.Name
            }
        } catch {
            Write-Log "$($check.Name) check failed: $($_.Exception.Message)" "ERROR"
            $failedChecks += $check.Name
        }
    }
    
    if ($failedChecks.Count -gt 0) {
        Write-Log "Health checks failed: $($failedChecks -join ', ')" "ERROR"
        return $false
    }
    
    Write-Log "All health checks passed" "SUCCESS"
    return $true
}

# Rollback function
function Invoke-Rollback {
    Write-Log "Initiating rollback procedure..." "WARN"
    
    # Find latest backup
    $backupDirs = Get-ChildItem -Path ".\backups" -Directory | Sort-Object CreationTime -Descending
    
    if ($backupDirs.Count -eq 0) {
        Write-Log "No backup found for rollback" "ERROR"
        throw "No backup found for rollback"
    }
    
    $latestBackup = $backupDirs[0].FullName
    Write-Log "Rolling back to backup: $latestBackup" "INFO"
    
    # Stop application services
    {stop_services_command}
    
    # Restore application files
    $applicationPath = "{application_path}"
    if (Test-Path $applicationPath) {
        Remove-Item -Path $applicationPath -Recurse -Force
    }
    Copy-Item -Path $latestBackup -Destination $applicationPath -Recurse -Force
    
    # Start application services
    {start_services_command}
    
    Write-Log "Rollback completed successfully" "SUCCESS"
}

# Main deployment function
function Start-Deployment {
    Write-Log "Starting deployment of $($Script:Config.ApplicationName) v$($Script:Config.ApplicationVersion)" "INFO"
    Write-Log "Environment: $Environment" "INFO"
    Write-Log "Generated by: $($Script:Metadata.Agent) on $($Script:Metadata.GeneratedDate)" "INFO"
    
    try {
        # Pre-deployment validation
        Test-PlatformCompatibility
        Install-Dependencies
        $config = Set-Configuration
        
        if (-not $DryRun) {
            Backup-CurrentDeployment
            
            # Deployment steps
            {deployment_steps}
            
            # Post-deployment validation
            if (Test-DeploymentHealth) {
                Write-Log "Deployment completed successfully!" "SUCCESS"
            } else {
                Write-Log "Deployment health checks failed. Consider rollback." "ERROR"
                exit 1
            }
        } else {
            Write-Log "Dry run completed successfully. No changes made." "SUCCESS"
        }
        
    } catch {
        Write-Log "Deployment failed: $($_.Exception.Message)" "ERROR"
        Write-Log "Check logs for details: $($Script:Config.LogPath)" "INFO"
        exit 1
    }
}

# Main execution
if ($Rollback) {
    Invoke-Rollback
} else {
    Start-Deployment
}

Write-Log "Script execution completed" "INFO"
```

## Bash Deployment Script Template

### 🐧 **Linux/macOS Bash Script (.sh)**
```bash
#!/bin/bash
# {application_name} Deployment Script
# Generated by Phoenix Agent on {current_date}
# Supports Linux (Ubuntu, CentOS, RHEL) and macOS

set -euo pipefail

# Script metadata
readonly SCRIPT_NAME="{application_name}-deploy"
readonly SCRIPT_VERSION="{application_version}"
readonly GENERATED_DATE="{current_date}"
readonly AGENT="Phoenix"

# Configuration
APPLICATION_NAME="{application_name}"
APPLICATION_VERSION="{application_version}"
ENVIRONMENT="${1:-production}"
CONFIG_PATH="${2:-./config}"
SKIP_DEPENDENCIES="${SKIP_DEPENDENCIES:-false}"
DRY_RUN="${DRY_RUN:-false}"
ROLLBACK="${ROLLBACK:-false}"

# Paths
LOG_PATH="./logs/deployment-$(date +%Y%m%d-%H%M%S).log"
BACKUP_PATH="./backups/backup-$(date +%Y%m%d-%H%M%S)"
APPLICATION_PATH="{application_path}"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${CYAN}[$timestamp] [INFO] $message${NC}"
    echo "[$timestamp] [INFO] $message" >> "$LOG_PATH"
}

log_success() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${GREEN}[$timestamp] [SUCCESS] $message${NC}"
    echo "[$timestamp] [SUCCESS] $message" >> "$LOG_PATH"
}

log_warning() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${YELLOW}[$timestamp] [WARN] $message${NC}"
    echo "[$timestamp] [WARN] $message" >> "$LOG_PATH"
}

log_error() {
    local message="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${RED}[$timestamp] [ERROR] $message${NC}"
    echo "[$timestamp] [ERROR] $message" >> "$LOG_PATH"
}

# Platform detection
detect_platform() {
    local os_name
    local arch
    local distro=""
    
    os_name=$(uname -s)
    arch=$(uname -m)
    
    case "$os_name" in
        Linux*)
            if [[ -f /etc/os-release ]]; then
                distro=$(grep '^ID=' /etc/os-release | cut -d'=' -f2 | tr -d '"')
            fi
            ;;
        Darwin*)
            distro="macos"
            ;;
    esac
    
    echo "$os_name-$arch-$distro"
}

# Dependency installation
install_dependencies() {
    if [[ "$SKIP_DEPENDENCIES" == "true" ]]; then
        log_info "Skipping dependency installation"
        return
    fi
    
    log_info "Installing dependencies..."
    local platform
    platform=$(detect_platform)
    
    case "$platform" in
        Linux*ubuntu*|Linux*debian*)
            sudo apt-get update
            {ubuntu_dependencies}
            ;;
        Linux*centos*|Linux*rhel*|Linux*fedora*)
            {centos_dependencies}
            ;;
        Darwin*)
            if command -v brew >/dev/null 2>&1; then
                {macos_dependencies}
            else
                log_error "Homebrew not found. Please install manually."
                exit 1
            fi
            ;;
        *)
            log_warning "Unknown platform: $platform"
            ;;
    esac
    
    log_success "Dependencies installed successfully"
}

# Configuration management
load_configuration() {
    log_info "Loading configuration for environment: $ENVIRONMENT"
    
    local config_file="$CONFIG_PATH/$ENVIRONMENT.json"
    if [[ ! -f "$config_file" ]]; then
        log_error "Configuration file not found: $config_file"
        exit 1
    fi
    
    # Export environment variables from JSON config
    while IFS='=' read -r key value; do
        export "$key"="$value"
        log_info "Set $key=$value"
    done < <(jq -r 'to_entries[] | "\(.key)=\(.value)"' "$config_file")
    
    log_success "Configuration loaded successfully"
}

# Health checks
run_health_checks() {
    log_info "Running deployment health checks..."
    
    local checks=(
        "Application Service:curl -f http://localhost:{application_port}/health"
        "Database Connection:{database_health_check}"
        "File System Access:test -d $APPLICATION_PATH"
    )
    
    local failed_checks=()
    
    for check in "${checks[@]}"; do
        local name="${check%%:*}"
        local command="${check#*:}"
        
        if eval "$command" >/dev/null 2>&1; then
            log_success "$name check passed"
        else
            log_error "$name check failed"
            failed_checks+=("$name")
        fi
    done
    
    if [[ ${#failed_checks[@]} -gt 0 ]]; then
        log_error "Health checks failed: ${failed_checks[*]}"
        return 1
    fi
    
    log_success "All health checks passed"
    return 0
}

# Main deployment function
main() {
    # Create log directory
    mkdir -p "$(dirname "$LOG_PATH")"
    
    log_info "Starting deployment of $APPLICATION_NAME v$APPLICATION_VERSION"
    log_info "Environment: $ENVIRONMENT"
    log_info "Platform: $(detect_platform)"
    log_info "Generated by: $AGENT on $GENERATED_DATE"
    
    if [[ "$ROLLBACK" == "true" ]]; then
        perform_rollback
        return
    fi
    
    # Pre-deployment steps
    install_dependencies
    load_configuration
    
    if [[ "$DRY_RUN" != "true" ]]; then
        # Backup current deployment
        create_backup
        
        # Deployment steps
        {deployment_steps}
        
        # Post-deployment validation
        if run_health_checks; then
            log_success "Deployment completed successfully!"
        else
            log_error "Deployment health checks failed. Consider rollback."
            exit 1
        fi
    else
        log_success "Dry run completed successfully. No changes made."
    fi
}

# Error handling
trap 'log_error "Script failed at line $LINENO"' ERR

# Execute main function
main "$@"
```

## Template Variables

### 📝 **Variable Substitutions**
```yaml
Template_Variables:
  application_info:
    - {application_name}: Name of the application being deployed
    - {application_version}: Version number of the application
    - {application_path}: Installation path for the application
    - {application_port}: Port number the application runs on
  
  deployment_info:
    - {current_date}: Current date in YYYY-MM-DD format
    - {environment}: Target deployment environment
    - {deployment_steps}: Platform-specific deployment commands
    - {dependency_list}: List of required dependencies
  
  health_checks:
    - {database_health_check}: Database connectivity test command
    - {api_health_check}: External API connectivity test
    - {service_health_check}: Application service status check
  
  platform_specific:
    - {ubuntu_dependencies}: Ubuntu/Debian package installation commands
    - {centos_dependencies}: CentOS/RHEL package installation commands
    - {macos_dependencies}: macOS Homebrew installation commands
    - {start_services_command}: Command to start application services
    - {stop_services_command}: Command to stop application services
```

This deployment script template provides a comprehensive foundation for cross-platform deployment automation, with built-in error handling, logging, health checks, and rollback capabilities.
